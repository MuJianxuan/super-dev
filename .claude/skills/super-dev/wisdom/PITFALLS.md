# 常见陷阱警告库 (Common Pitfalls)

> 来自真实项目失败的血泪教训，帮助用户避开常见坑。

---

## 产品陷阱 (12 条)

### P1: 假设即事实
**错误**: "我觉得用户需要这个功能"
**数据**: 80% 的功能上线后日活 < 5%
**后果**: 浪费开发资源，产品臃肿
**正确做法**: 
- 用户调研验证需求
- MVP 快速测试
- 看数据，不看感觉

### P2: 功能堆砌
**错误**: "竞品有50个功能，我们要有60个"
**数据**: 用户平均只使用 20% 的功能
**后果**: 维护成本指数增长，用户反而困惑
**正确做法**: 
- 做好3个功能 > 做30个平庸功能
- 90-9-1 原则：90%用户是观众

### P3: MVP 不够 M
**错误**: "这个也得有，那个也不能少"
**数据**: 过大的 MVP 平均延期 3 倍时间
**后果**: 永远无法上线，错过市场窗口
**正确做法**: 
- 问："如果只能做一个功能，做哪个？"
- 删到不能再删

### P4: 忽视留存只看增长
**错误**: "用户量在涨，没问题"
**数据**: 没有留存的增长是在往漏桶倒水
**后果**: 花了钱获客，但留不住
**正确做法**: 
- 先做到 40% 的次日留存
- 留存 > 增长

### P5: 定价后置
**错误**: "先免费培养用户，以后再收费"
**数据**: 免费用户付费转化率通常 < 3%
**后果**: 养成的是薅羊毛习惯，不是付费习惯
**正确做法**: 
- Day 1 就设计盈利模式
- 免费要有策略（Freemium）

### P6: 伪需求
**错误**: "用户说他想要这个功能"
**真相**: 用户说的 ≠ 用户想要的 ≠ 用户需要的
**正确做法**: 
- 看用户做什么，不只是听用户说什么
- 问 5 个"为什么"找到真实需求

### P7: 抄竞品
**错误**: "XX有这个功能，我们也要有"
**后果**: 永远是跟随者，没有差异化
**正确做法**: 
- 研究竞品的"为什么"，不只是"是什么"
- 找到竞品没覆盖的细分需求

### P8: 需求蔓延
**错误**: "这个小需求顺便加一下"
**数据**: 需求蔓延导致项目延期平均 50%
**后果**: 项目永远完不成
**正确做法**: 
- 所有需求走优先级评估
- 有 In 就有 Out

### P9: 没有明确的成功指标
**错误**: "上线看看效果"
**后果**: 不知道成功还是失败
**正确做法**: 
- 发布前定义好成功/失败标准
- 用数据说话

### P10: 忽视竞品迭代
**错误**: "我们已经调研过竞品了"
**后果**: 竞品可能已经迭代了关键功能
**正确做法**: 
- 持续监控竞品
- 至少每季度更新竞品分析

### P11: 技术驱动而非用户驱动
**错误**: "这个技术很酷，我们可以..."
**后果**: 做出用户不需要的东西
**正确做法**: 
- 先问"解决什么问题"
- 技术是手段，不是目的

### P12: 团队意见 = 用户意见
**错误**: "我们内部讨论觉得..."
**后果**: 团队不代表目标用户
**正确做法**: 
- 找真实目标用户测试
- 内部意见要用数据验证

---

## 架构陷阱 (10 条)

### A1: 过早优化
**错误**: "未来可能有千万用户，现在就设计分布式"
**数据**: 90% 的产品达不到需要分布式的规模
**后果**: 复杂度激增，开发变慢 10 倍
**正确做法**: 
- 先让业务跑起来
- 有真实瓶颈再优化
- 不要解决不存在的问题

### A2: 单体恐惧症
**错误**: "单体架构太土了，必须微服务"
**数据**: 微服务运维成本是单体的 3-5 倍
**后果**: 3个人维护20个服务
**正确做法**: 
- 团队 < 10 人慎用微服务
- 从模块化单体开始

### A3: 忽视单点故障
**错误**: "这个服务不会挂的"
**后果**: 核心服务挂了全崩
**正确做法**: 
- 假设一切都会失败
- 关键服务必须有冗余

### A4: 安全后置
**错误**: "先做功能，安全以后加"
**后果**: 被拖库，数据泄露，公司关门
**正确做法**: 
- 安全设计前置
- OWASP Top 10 必须考虑

### A5: 无 ADR 记录
**错误**: "这个架构是老王设计的，他知道为什么"
**后果**: 老王离职后没人知道为什么这样
**正确做法**: 
- 关键技术决策写 ADR
- 记录 Why, not just What

### A6: 数据库滥用
**错误**: "所有数据都放 MySQL"
**后果**: 关系型数据库做全文搜索、时序数据...
**正确做法**: 
- 不同数据选合适的存储
- 搜索用 ES，缓存用 Redis

### A7: 没有可观测性
**错误**: "线上有问题了再看日志"
**后果**: 出问题后花几小时定位
**正确做法**: 
- 三大支柱：Logs, Metrics, Traces
- 监控告警先行

### A8: 环境不一致
**错误**: "我本地是好的啊"
**后果**: 测试通过但线上出问题
**正确做法**: 
- 容器化保证环境一致
- 生产化的测试环境

### A9: 无灾备
**错误**: "我们用的云服务，不会挂"
**后果**: 云服务商事故，业务完全中断
**正确做法**: 
- 定期备份
- 灾难恢复演练

### A10: API 无版本
**错误**: "直接改接口就行"
**后果**: 客户端兼容性问题
**正确做法**: 
- API 版本控制
- 向后兼容原则

---

## 设计陷阱 (6 条)

### D1: 设计师视角
**错误**: "这个设计很漂亮"
**真相**: 设计师觉得好 ≠ 用户觉得好
**正确做法**: 
- 用户测试
- A/B 测试
- 数据说话

### D2: 移动端无视
**错误**: "先做桌面，移动端适配一下"
**数据**: 70%+ 用户在移动端
**正确做法**: 
- Mobile First
- 先设计小屏，再扩展

### D3: 无障碍忽视
**错误**: "这个颜色很好看"
**数据**: 8% 男性是色盲
**后果**: 部分用户无法使用
**正确做法**: 
- WCAG 2.1 AA 标准
- 颜色对比度 >= 4.5:1

### D4: 加载状态缺失
**错误**: "加载一下就出来了"
**后果**: 用户不知道在干嘛，反复点击
**正确做法**: 
- 超过 300ms 显示 Loading
- 骨架屏比 Spinner 好

### D5: 错误信息无用
**错误**: "发生错误，请重试"
**后果**: 用户不知道怎么解决
**正确做法**: 
- 说明具体原因
- 提供恢复建议

### D6: 只有成功路径
**错误**: "正常流程设计好了"
**后果**: 异常情况体验灾难
**正确做法**: 
- 设计所有状态：空/错误/网络差/权限不足

---

## 代码陷阱 (7 条)

### C1: 复制粘贴
**错误**: "改一改就能用"
**后果**: Bug 也复制了
**正确做法**: 
- 理解后再用
- 抽取公共逻辑

### C2: 无测试
**错误**: "手动测过了"
**后果**: 回归问题层出不穷
**正确做法**: 
- 核心逻辑单元测试
- 覆盖率 > 70%

### C3: 吞掉异常
**错误**: `catch(e) {}`
**后果**: 问题被隐藏，难以排查
**正确做法**: 
- 异常必须处理或上报
- 至少打日志

### C4: 魔法数字
**错误**: `if (status === 3)`
**后果**: 没人知道 3 是什么意思
**正确做法**: 
- 用常量 `STATUS_COMPLETED`
- 有意义的命名

### C5: 过早抽象
**错误**: "这个可能复用，先抽个父类"
**后果**: 不合理的抽象比重复代码更糟
**正确做法**: 
- Rule of Three
- 复用 3 次再抽象

### C6: 注释过时
**错误**: 代码改了，注释没更新
**后果**: 注释比没有更糟糕
**正确做法**: 
- 删除过时注释
- 代码本身表达意图

### C7: 大函数
**错误**: 一个函数 500 行
**后果**: 无法理解、无法测试
**正确做法**: 
- 函数 < 50 行
- 单一职责

---

## 如何使用

1. **文档生成阶段**: 检查是否踩了对应领域的陷阱
2. **三轮审查阶段**: 对照陷阱列表逐条验证
3. **交付阶段**: 附上相关陷阱警告，提醒用户
